<!--
 * @Author: yowayimono
 * @Date: 2023-08-05 00:05:27
 * @LastEditors: yowayimono
 * @LastEditTime: 2023-08-05 00:21:01
 * @Description: nothing
-->
这个虚拟机是一个简单的栈式虚拟机，其指令集包含了一些基本的算术操作、条件跳转、函数调用、数据加载与存储等功能。以下是对给出的代码进行总结：

1. 枚举常量：定义了虚拟机的操作码、寄存器索引、中断号等常量。

2. 数据结构定义：
   - `VM_CPU` 结构体：用于表示虚拟机的CPU状态，包括通用寄存器、程序计数器、栈指针和状态标志位。
   - `TOYVM` 结构体：虚拟机的主结构体，包含内存、内存大小、栈大小和CPU状态等信息。

3. 指令定义：
   - `instruction` 结构体：用于定义每条指令的操作码、长度和执行函数。
   - `instructions` 数组：包含所有指令的信息，用于通过操作码查找对应的执行函数。

4. 功能函数定义：
   - 各种工具函数用于处理内存和栈的读写、状态标志位设置、校验指令是否在内存中等。

5. 主要执行函数：
   - `RunVM(TOYVM* vm)`: 执行虚拟机的主循环，不断读取指令并调用相应的执行函数，直到遇到 `HALT` 指令或发生异常。

6. 指令执行函数：
   - 每个指令都有相应的执行函数，用于实现虚拟机的功能。这些函数根据具体的指令格式，从内存中读取操作数、处理运算、修改寄存器和状态标志位，实现虚拟机的指令集功能。

虚拟机的指令集包含了基本的算术运算、条件跳转、函数调用和数据加载与存储等操作，使得虚拟机能够执行一些简单的程序。它的设计是栈式架构，使用栈来保存临时数据和函数调用的上下文，指令从内存中读取并操作栈上的数据。

总体而言，这是一个简单的栈式虚拟机实现，适用于执行一些简单的程序。虽然它在功能和灵活性上可能不如现代高级虚拟机，但对于教学和学习目的来说，是一个很好的入门示例。



这个虚拟机能完成以下操作：

1. **算术运算：** 包括整数加法（ADD）、取反（NEG）、乘法（MUL）、除法（DIV）和取模（MOD）操作。

2. **条件跳转：** 能够根据比较结果进行条件跳转，包括无条件跳转（JMP）以及比较两个寄存器值并根据结果跳转（JA、JE、JB）。

3. **函数调用与返回：** 支持函数的调用（CALL）和返回（RET），能够保存和恢复返回地址，实现函数的嵌套调用。

4. **数据加载与存储：** 可以从内存中读取数据到寄存器（LOAD）和将寄存器值存储到内存中（STORE、RSTORE），以及将常量加载到寄存器（CONST）。

5. **栈操作：** 支持将寄存器值推入栈（PUSH）、将栈顶值弹出并存储到寄存器（POP）、将所有通用寄存器的值推入栈（PUSH_ALL）以及将所有通用寄存器的值从栈中弹出（POP_ALL）。

6. **中断处理：** 可以触发中断指令（INT），并根据中断号执行相应的操作，例如打印整数或字符串。

7. **栈指针操作：** 能够获取当前栈指针值（LSP），将其存储到指定寄存器。

8. **其他指令：** 包括停机指令（HALT）用于停止虚拟机的执行，以及空操作指令（NOP）不做任何操作，只用于占据一个字节。

虚拟机的指令集虽然简单，但这些指令足以执行一些基本的程序和计算任务。它提供了一种简单的方式来模拟计算机的基本操作，适用于教学、学习和实验等用途。


虚拟机指令集（中文翻译）：

算术指令
0x01：加法（ADD REGi REGj） - 将寄存器REGi中的整数加到寄存器REGj中。
0x02：取反（NEG REGi） - 将寄存器REGi中存储的整数取反。
0x03：乘法（MUL REGi REGj） - 将寄存器REGi和REGj中的整数相乘，并将结果复制到REGj中。
0x04：除法（DIV REGi REGj） - 将寄存器REGi和REGj中的整数相除，并将结果复制到REGj中。
0x05：取模（MOD REGi REGj） - 将寄存器REGi中的整数除以寄存器REGj中的整数，将余数存储到REGj中。

条件指令
0x10：比较（CMP REGi REGj） - 比较寄存器REGi中的值与寄存器REGj中的值。
0x11：大于跳转（JA ADDRESS） - 仅当vm.cpu.status的COMPARISON_ABOVE标志被设置时跳转到地址ADDRESS。
0x12：等于跳转（JE ADDRESS） - 仅当vm.cpu.status的COMPARISON_EQUAL标志被设置时跳转到地址ADDRESS。
0x13：小于跳转（JB ADDRESS） - 仅当vm.cpu.status的COMPARISON_BELOW标志被设置时跳转到地址ADDRESS。
0x14：无条件跳转（JMP ADDRESS） - 无条件跳转到地址ADDRESS。

子程序指令
0x20：调用子程序（CALL ADDRESS） - 将返回地址（即ADDRESS + 5）压入栈中，然后跳转到指定地址的指令。
0x21：返回（RET） - 弹出返回地址，并将其设置为程序计数器，从子程序返回。

内存和数据指令
0x30：加载（LOAD REGi ADDRESS） - 将ADDRESS地址处的值存储到寄存器REGi中。
0x31：存储（STORE REGi ADDRESS） - 将寄存器REGi中的值存储到ADDRESS地址处的内存中。
0x32：常量（CONST REGi DATA） - 将DATA的值存储到寄存器REGi中。
0x33：寄存器加载（RLOAD REGi REGj） - 加载寄存器REGi中地址处的字到寄存器REGj中。
0x34：寄存器存储（RSTORE REGi REGj） - 将寄存器REGi中的内容存储到寄存器REGj中的地址处。

辅助指令
0x40：停机（HALT） - 停止虚拟机执行。
0x41：中断（INT INTERRUPT_NUMBER） - 发出具有中断号INTERRUPT_NUMBER的中断。
0x42：无操作（NOP） - 一个无操作指令，除了将程序计数器增加到下一条指令外，不执行其他操作。

栈指令
0x50：压栈（PUSH REGi） - 将寄存器REGi中的内容压入栈中。
0x51：全压栈（PUSH_ALL） - 将所有四个寄存器的内容压入栈中。
0x52：出栈（POP REGi） - 弹出栈中的内容并存储到寄存器REGi中。
0x53：全出栈（POP_ALL） - 将栈中的所有内容依次弹出并存储到寄存器中。
0x54：加载栈指针（LSP REGi） - 将栈指针的值加载到寄存器REGi中。